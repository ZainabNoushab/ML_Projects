# -*- coding: utf-8 -*-
"""Stock Market Prediction and Forecasting using Stacked LSTM

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YEVt92c4jem4FcvsTFIo9GK1wJdRQh9P

#Keras and Tensorflow
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import math

df = pd.read_csv('AAPL.csv')

df.head()

# Keep Date column as index for meaningful plots
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Focus on close prices
data = df[['close']]

data.shape

data

plt.figure(figsize=(12,6))
plt.plot(data, label="Closing Price")
plt.title("Apple Stock Closing Price")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()

"""###LSTM are sensitive to the state of scale of the data, so we apply MinMax scaler"""

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(data)

"""## Splitting dataset into into training and testing data"""

training_size = int(len(scaled_data)*0.65)
train_data = scaled_data[:training_size]
test_data = scaled_data[training_size:]

def create_dataset(dataset, time_step=60):
    X, y = [], []
    for i in range(len(dataset)-time_step-1):
        X.append(dataset[i:(i+time_step), 0])
        y.append(dataset[i+time_step, 0])
    return np.array(X), np.array(y)

# reshape into X=t,t+1,t+2,t+3 and t+4
time_step = 100
x_train, y_train = create_dataset(train_data, time_step)
x_test, y_test = create_dataset(test_data, time_step)

# Reshape into [samples, time steps, features] which is required for LSTM
x_train = x_train.reshape(x_train.shape[0], x_train.shape[1], 1)
x_test = x_test.reshape(x_test.shape[0], x_test.shape[1], 1)

print("Training set:", x_train.shape, y_train.shape)
print("Testing set:", x_test.shape, y_test.shape)

# Create the Stacked LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
model.add(Dropout(0.2))
model.add(LSTM(50, return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(50))
model.add(Dense(1))

model.compile(loss="mean_squared_error", optimizer="adam")

model.summary()

#Train model with early stopping
early_stop = EarlyStopping(monitor="val_loss", patience=10, restore_best_weights=True)

history = model.fit(
    x_train, y_train,
    validation_data=(x_test, y_test),
    epochs=100,
    batch_size=64,
    verbose=1,
    callbacks=[early_stop]
)

# Let's do the prediction and check performance metrics
train_predict=model.predict(x_train)
test_predict=model.predict(x_test)

# Transform back to original scale
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)
y_train_true = scaler.inverse_transform(y_train.reshape(-1,1))
y_test_true = scaler.inverse_transform(y_test.reshape(-1,1))

#Calculate RSME performance metrics
rmse_train = math.sqrt(mean_squared_error(y_train_true, train_predict))
rmse_test = math.sqrt(mean_squared_error(y_test_true, test_predict))
mae = mean_absolute_error(y_test_true, test_predict)
r2 = r2_score(y_test_true, test_predict)

print(f"Train RMSE: {rmse_train:.2f}")
print(f"Test RMSE: {rmse_test:.2f}")
print(f"Test MAE: {mae:.2f}")
print(f"Test RÂ² Score: {r2:.2f}")

"""#Plotting"""

look_back = time_step

train_plot = np.empty_like(scaled_data)
train_plot[:, :] = np.nan
train_plot[look_back:len(train_predict)+look_back, :] = train_predict

test_plot = np.empty_like(scaled_data)
test_plot[:, :] = np.nan
test_plot[len(train_predict)+(look_back*2)+1:len(scaled_data)-1, :] = test_predict

plt.figure(figsize=(12,6))
plt.plot(scaler.inverse_transform(scaled_data), label="Actual Price")
plt.plot(train_plot, label="Train Predictions")
plt.plot(test_plot, label="Test Predictions")
plt.title("Stock Price Prediction")
plt.xlabel("Days")
plt.ylabel("Price")
plt.legend()
plt.show()

"""#Forecasting next 30 days"""

future_predictions = []
temp_input = list(test_data[-time_step:].flatten()) # Flatten the initial numpy array

for i in range(30):
    x_input = np.array(temp_input[-time_step:]).reshape(1, time_step, 1)
    yhat = model.predict(x_input, verbose=0)
    temp_input.append(yhat[0][0])  # Append the scalar prediction
    future_predictions.append(yhat[0][0])

future_predictions = scaler.inverse_transform(np.array(future_predictions).reshape(-1,1))

# Plot last 100 days + future predictions
plt.figure(figsize=(12,6))
last_days = scaler.inverse_transform(test_data[-100:])
plt.plot(np.arange(1,101), last_days, label="Last 100 days")
plt.plot(np.arange(101,131), future_predictions, label="Next 30 days")
plt.title("Future Forecast")
plt.xlabel("Days")
plt.ylabel("Price")
plt.legend()
plt.show()